## 오늘 한 일
📃 **나만의 사전 만들기**
 - **시간순으로 카드 정렬하기(내림차순)**
 
① **카드를 추가할 때 시간 얻기** 
카드를 시간순으로 정렬하기 위해서는 카드를 적을 때 그 적은 시간을 가져와야한다.
`Date.now()`는 **현재 시간의 Timestamp**를 리턴한다.

➕ **Timestamp** : 1970년 1월 1일부터 지금까지 경과한 시간을 millisecond로 변환한 값, 서로 다른 시간을 비교할 때 **숫자의 크기 비교만으로** 시간 상의 전, 후를 비교를 할 수 있다.

```javascript
    const addWordList = () => {
        dispatch(createWordFB({
            word : word.current.value,
            mean : mean.current.value,
            ex : ex.current.value,
            read : read.current.value,
            completed : false,
            date: Date.now(),
        }));
        history.goBack();
      };
```
 
② **정렬 순서 정하기**
제일 늦게 작성한게 맨 위로 올라와야해서 내림차순으로 정렬해야 한다.
```javascript
   word_list.sort((a,b) => {
      return b.date - a.date;
    })
```
`sort()` 정렬을 도와주는 메소드인데 기본적으로 문자열을 정렬해준다. 다만, 숫자를 정렬하려면 **비교함수를 지정**해 줘야한다.
> 오름차순 기준!
a,b 두 요소를 전달하고 a - b로 크기를 비교해서 양수인지, 음수인지, 0인지 봐준다.
a > b : 양수  ------------> b를 앞으로 내보냄
a = b : 0   --------------> 그대로 있음
a < ｂ : 음수 -----------> a를 앞으로 내보냄


<br/>

-----------------------------
- **단어 외우기를 완료(ture)/미완료(false) 체크하기**
단어를 추가하면 아직 외우지 않았기 때문에 기본값으로 false로 지정한다.
check 버튼을 누르면 true로 바뀌고 또 다시 누르면 false로 해야하기 때문에 파이어베이스에 저장을 하고 버튼을 누를 때마다 수정하도록 한다. 
 
① **액션 타입**
```javascript
const UPDATE = 'words/UPDATE';
```
② **액션 생성 함수**
```javascript
export function updateWord(word_index) {
  return { type: UPDATE, word_index };
}
```

③ **파이어베이스랑 통신하는 함수 = 미들웨어**
```javascript
export const updateWordFB = (word, word_id) => {
  return async function(dispatch, getState) {
    const docRef = doc(db, "words", word_id); // 어떤 카드의 check button을 눌렀는지 확인 하기 위해 word_id를 가져와야 한다.
    await updateDoc(docRef, {completed: !word.completed}); // 바꿀 데이터를 작성 : word의 completed 필드를 true면 false, fasle면 true로 바꿈 

    const _word_list = getState().words.list; // 모든 데이터 가져옴
    const word_index = _word_list.findIndex((l) => { // 모든 데이터의 id와 내가 누른 카드의 id와 같은지 비교! 같으면 그 index 번호를 return
      return l.id === word_id;
    })

    dispatch(updateWord(word_index));
  }
}
```

`Array.prototype.findIndex()` : 주어진 판별 함수를 만족하는 **배열의 첫 번째 요소에 대한 인덱스를 반환**
```javascript
(example)

const array1 = [5, 12, 8, 130, 44];
const isLargeNumber = (element) => element > 13;
console.log(array1.findIndex(isLargeNumber));
// expected output: 3
```


④ **리듀서 함수**
```javascript
export default function reducer(state = initialState, action = {}) {
    switch (action.type) {
      case "words/UPDATE": {
        const new_word_list = state.list.map((b, idx) => 
          parseInt(action.word_index) === idx ? { ...b, completed: !b.completed } : b);
        return { ...state, list: new_word_list };
      }
      default:
      	return state;
    }
  }   
```

⑤ **check버튼 누르면 false/true**
```javascript
import { createWordFB } from "../redux/modules/words"; 

const dispatch = useDispatch(); 

<CardBox key={index} id={list.id} completed={list.completed}>
<button type="button" className="btn_check" 
onClick={() => { dispatch(updateWordFB(list, list.id));}}>
  	{list.completed ? <BsCheckCircleFill size="25"/> : <BsCheckCircle size="25"/> }</button>

const CardBox = styled.div`
    background-color: ${(props) => (props.completed ? "#F47C7C" : "#FFFFFF")};
    color: ${(props) => (props.completed ? "#FFFFFF" : "black")};
`;

```

## 오늘 느낀점
필수적으로 구현해야 할 것들은 다 해서 다른 것들을 만져봤다. 강의에서 하는 부분들이 아니라서 하나를 하는데 시간이 엄청 걸렸고 무엇보다도 머리가 안돌아갔다. 막상 끝나서 보면 별거 아닌 코드인데 이 별거 아닌 코드가 왜이렇게 생각이 안났지 싶어서 스스로가 멍청이가 아닐까 하는 생각을 엄청 했던 것 같다. 결국엔 이것 저것 찾아보면서 해결 했지만 뭔가 찝찝한 기분이다. 내가 해냈다! 이런 것보다 아 해결은 했네,, 이런 느낌? 리덕스가 밉다 파이어 스토어가 밉다 